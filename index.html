<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Melody's Mystery Elevator</title>
  <link href="jspsych.css" rel="stylesheet" />
  <script src="jspsych.js"></script>
  <style>
    body {
      text-align: center;
      padding-top: 50px;
      background-color: #f0f0f0;
    }
    #visual-container {
      width: 1200px;
      height: 800px;
      margin: auto;
      background-color: white;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    video, img {
      max-width: 100%;
      max-height: 100%;
      display: none;
    }
  </style>
</head>
<body>

<div id="visual-container">
  <img id="stillframe1" src="stillframe1.png" />
  <img id="gapStillframe" src="gapStillframe.png" />
  <img id="stillframe2" src="stillframe2.png" />
  <video id="video1" src="video1.mp4" playsinline preload="auto" muted></video>
  <video id="gapVideo" src="gapVideo.mp4" playsinline preload="auto" muted></video>
  <video id="video2" src="video2.mp4" playsinline preload="auto" muted></video>
</div>

<audio id="myAudio" hidden preload="auto"></audio>
<br />
<button id="playButton">Play Synced Stimuli</button>

<script>
document.getElementById("playButton").addEventListener("click", async function () {
  const audio = document.getElementById("myAudio");
  const still1 = document.getElementById("stillframe1");
  const still2 = document.getElementById("stillframe2");
  const gapStill = document.getElementById("gapStillframe");
  const v1 = document.getElementById("video1");
  const vGap = document.getElementById("gapVideo");
  const v2 = document.getElementById("video2");

  const visuals = [
    { el: still1, start: 0, end: 0 },
    { el: v1, start: 0, end: 0 },
    { el: gapStill, start: 0, end: 0 },
    { el: vGap, start: 0, end: 0 },
    { el: v2, start: 0, end: 0 },
    { el: still2, start: 0, end: 0 }
  ];

  function hideAll() {
    [still1, still2, gapStill, v1, vGap, v2].forEach(el => {
      el.style.display = "none";
      if (el.tagName === "VIDEO") {
        el.pause();
        el.currentTime = 0;
      }
    });
  }

  hideAll();

  try {
    const response = await fetch("audio_files.csv");
    if (!response.ok) throw new Error("CSV file not found");
    const text = await response.text();
    const rows = text.trim().split("\n").slice(1).map(r => r.split(",").map(x => x.trim()));
    if (rows.length === 0) throw new Error("No valid audio rows found");

    const [filename, original, gap, test] = rows[Math.floor(Math.random() * rows.length)];
    const originalSec = parseFloat(original);
    const gapSec = parseFloat(gap);
    const testSec = parseFloat(test);
    const audioURL = filename;

    // Load video durations
    await Promise.all([
      v1.play().then(() => v1.pause()),
      vGap.play().then(() => vGap.pause()),
      v2.play().then(() => v2.pause())
    ]);

    const video1Sec = v1.duration;
    const gapVideoSec = vGap.duration;
    const video2Sec = v2.duration;

    // Compute raw durations
    const preStillSec = originalSec - video1Sec;
    const gapStillSec = gapSec - gapVideoSec;
    const postStillSec = testSec - video2Sec;

    // Clamp to non-negative durations
    const clamp = (val) => Math.max(0, val);
    const preStillClamped = clamp(preStillSec);
    const gapStillClamped = clamp(gapStillSec);
    const postStillClamped = clamp(postStillSec);

    // Assign exact visual timing
    let t = 0;
    visuals[0].start = t;
    visuals[0].end = t += preStillClamped;

    visuals[1].start = t;
    visuals[1].end = t += video1Sec;

    visuals[2].start = t;
    visuals[2].end = t += gapStillClamped;

    visuals[3].start = t;
    visuals[3].end = t += gapVideoSec;

    visuals[4].start = t;
    visuals[4].end = t += video2Sec;

    visuals[5].start = t;
    visuals[5].end = t += postStillClamped;

    const totalSec = visuals[5].end;

    // Load audio
    audio.src = audioURL;
    await new Promise((resolve, reject) => {
      audio.oncanplaythrough = resolve;
      audio.onerror = () => reject("Audio failed to load: " + audioURL);
    });

    // Start sync
    let currentVisual = null;
    function updateVisuals() {
      const t = audio.currentTime;
      for (const v of visuals) {
        if (t >= v.start && t < v.end) {
          if (currentVisual !== v.el) {
            hideAll();
            v.el.style.display = "block";
            if (v.el.tagName === "VIDEO") v.el.play();
            currentVisual = v.el;
          }
          break;
        }
      }
      if (t < totalSec) {
        requestAnimationFrame(updateVisuals);
      } else {
        hideAll();
        console.log("Sequence complete.");
      }
    }

    await audio.play();
    updateVisuals();

  } catch (err) {
    console.error("Sync error:", err);
    alert("Error playing synced sequence. See console for details.");
  }
});
</script>

</body>
</html>
